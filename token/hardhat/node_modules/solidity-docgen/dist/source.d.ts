declare type ContractTemplate = (contract: SourceContract) => string;
import { SolcOutput, ast } from './solc';
export declare class Source {
    private readonly contractsDir;
    private readonly solcOutput;
    readonly contractTemplate: ContractTemplate;
    constructor(contractsDir: string, solcOutput: SolcOutput, contractTemplate: ContractTemplate);
    get contracts(): SourceContract[];
    get files(): SourceFile[];
    file(fileName: string): SourceFile;
    fileById(id: number): SourceFile;
    contractById(id: number): SourceContract;
}
declare class SourceFile {
    readonly source: Source;
    readonly ast: ast.SourceUnit;
    readonly path: string;
    constructor(source: Source, ast: ast.SourceUnit, path: string);
    get contracts(): SourceContract[];
    get contractsInScope(): Record<string, SourceContract>;
    get astId(): number;
}
export interface Linkable {
    anchor: string;
    name: string;
    fullName: string;
}
export declare class SourceContract implements Linkable {
    private readonly source;
    readonly file: SourceFile;
    private readonly astNode;
    constructor(source: Source, file: SourceFile, astNode: ast.ContractDefinition);
    toString(): string;
    get name(): string;
    get fullName(): string;
    get anchor(): string;
    get linkable(): Linkable[];
    get inheritance(): SourceContract[];
    get variables(): SourceStateVariable[];
    get ownVariables(): SourceStateVariable[];
    get functions(): SourceFunction[];
    get ownFunctions(): SourceFunction[];
    get privateFunctions(): SourceFunction[];
    get inheritedItems(): InheritedItems[];
    get events(): SourceEvent[];
    get ownEvents(): SourceEvent[];
    get modifiers(): SourceModifier[];
    get ownModifiers(): SourceModifier[];
    get structs(): SourceStruct[];
    get ownStructs(): SourceStruct[];
    get enums(): SourceEnum[];
    get ownEnums(): SourceEnum[];
    get natspec(): NatSpec;
    get astId(): number;
}
declare abstract class SourceContractItem implements Linkable {
    readonly contract: SourceContract;
    protected abstract astNode: Exclude<ast.ContractItem, ast.VariableDeclaration>;
    constructor(contract: SourceContract);
    get name(): string;
    get fullName(): string;
    get anchor(): string;
}
declare abstract class SourceFunctionLike extends SourceContractItem {
    readonly contract: SourceContract;
    protected abstract astNode: ast.FunctionDefinition | ast.ModifierDefinition | ast.EventDefinition;
    constructor(contract: SourceContract);
    get anchor(): string;
    get args(): SourceTypedVariable[];
    get signature(): string;
    get natspec(): NatSpec;
}
declare class SourceStateVariable implements Linkable {
    readonly contract: SourceContract;
    protected readonly astNode: ast.VariableDeclaration;
    constructor(contract: SourceContract, astNode: ast.VariableDeclaration);
    get name(): string;
    get fullName(): string;
    get anchor(): string;
    get type(): string;
    get signature(): string;
    get natspec(): {};
}
declare class SourceStructVariable {
    readonly struct: SourceStruct;
    protected readonly astNode: ast.VariableDeclaration;
    constructor(struct: SourceStruct, astNode: ast.VariableDeclaration);
    get name(): string;
    get type(): string;
}
declare class SourceFunction extends SourceFunctionLike {
    protected readonly astNode: ast.FunctionDefinition;
    constructor(contract: SourceContract, astNode: ast.FunctionDefinition);
    get name(): string;
    get outputs(): SourceTypedVariable[];
    get visibility(): 'internal' | 'external' | 'public' | 'private';
    get isTrivialConstructor(): boolean;
}
declare class SourceEvent extends SourceFunctionLike {
    protected readonly astNode: ast.EventDefinition;
    constructor(contract: SourceContract, astNode: ast.EventDefinition);
}
declare class SourceModifier extends SourceFunctionLike {
    protected readonly astNode: ast.ModifierDefinition;
    constructor(contract: SourceContract, astNode: ast.ModifierDefinition);
}
declare class SourceStruct extends SourceContractItem {
    protected readonly astNode: ast.StructDefinition;
    constructor(contract: SourceContract, astNode: ast.StructDefinition);
    get members(): SourceStructVariable[];
    get natspec(): {};
}
declare class SourceEnum extends SourceContractItem {
    protected readonly astNode: ast.EnumDefinition;
    constructor(contract: SourceContract, astNode: ast.EnumDefinition);
    get members(): string[];
    get natspec(): {};
}
declare class SourceTypedVariable {
    private readonly typeNode;
    readonly name?: string | undefined;
    constructor(typeNode: ast.TypeName, name?: string | undefined);
    get type(): string;
    get typeName(): string;
    toString(): string;
}
interface InheritedItems {
    contract: SourceContract;
    variables: SourceStateVariable[];
    functions: SourceFunction[];
    events: SourceEvent[];
    modifiers: SourceModifier[];
    structs: SourceStruct[];
    enums: SourceEnum[];
}
interface NatSpec {
    devdoc?: string;
    userdoc?: string;
    title?: string;
    params?: {
        param: string;
        description: string;
    }[];
    returns?: {
        param: string;
        description: string;
    }[];
    custom?: {
        [tag: string]: string;
    };
}
export {};
//# sourceMappingURL=source.d.ts.map