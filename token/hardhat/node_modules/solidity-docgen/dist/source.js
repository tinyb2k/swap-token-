"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceContract = exports.Source = void 0;
const lodash_1 = require("lodash");
const path_1 = __importDefault(require("path"));
const memoize_1 = require("./memoize");
const handlebars_1 = require("./handlebars");
class Source {
    constructor(contractsDir, solcOutput, contractTemplate) {
        this.contractsDir = contractsDir;
        this.solcOutput = solcOutput;
        this.contractTemplate = contractTemplate;
    }
    get contracts() {
        return (0, lodash_1.flatten)(this.files.map(file => file.contracts));
    }
    get files() {
        return Object.keys(this.solcOutput.sources)
            .map(fileName => this.file(fileName));
    }
    file(fileName) {
        return new SourceFile(this, this.solcOutput.sources[fileName].ast, path_1.default.relative(this.contractsDir, fileName));
    }
    fileById(id) {
        const file = this.files.find(f => f.astId === id);
        if (file === undefined) {
            throw new Error(`File with id ${id} not found`);
        }
        return file;
    }
    contractById(id) {
        const contract = this.contracts.find(c => c.astId === id);
        if (contract === undefined) {
            throw new Error(`Contract with id ${id} not found`);
        }
        return contract;
    }
}
__decorate([
    memoize_1.memoize
], Source.prototype, "file", null);
exports.Source = Source;
class SourceFile {
    constructor(source, ast, path) {
        this.source = source;
        this.ast = ast;
        this.path = path;
    }
    get contracts() {
        const astNodes = this.ast.nodes.filter(isContractDefinition);
        return astNodes.map(node => new SourceContract(this.source, this, node));
    }
    get contractsInScope() {
        return contractsInScope(this);
    }
    get astId() {
        return this.ast.id;
    }
}
__decorate([
    memoize_1.memoize
], SourceFile.prototype, "contracts", null);
__decorate([
    memoize_1.memoize
], SourceFile.prototype, "contractsInScope", null);
function contractsInScope(file, stack = new Set(), aliasedImport = false) {
    var _a;
    if (stack.has(file)) {
        if (aliasedImport) {
            throw new Error('Circular dependency detected: aliased imports not supported');
        }
        else {
            return {};
        }
    }
    stack.add(file);
    const scope = {};
    for (const c of file.contracts) {
        scope[c.name] = c;
    }
    const imports = file.ast.nodes.filter(isImportDirective);
    for (const i of imports) {
        const importedFile = file.source.fileById(i.sourceUnit);
        const importedScope = contractsInScope(importedFile, stack, aliasedImport || i.symbolAliases.length > 0);
        if (i.symbolAliases.length === 0) {
            Object.assign(scope, importedScope);
        }
        else {
            for (const a of i.symbolAliases) {
                scope[(_a = a.local) !== null && _a !== void 0 ? _a : a.foreign.name] = importedScope[a.foreign.name];
            }
        }
    }
    ;
    stack.delete(file);
    return scope;
}
class SourceContract {
    constructor(source, file, astNode) {
        this.source = source;
        this.file = file;
        this.astNode = astNode;
    }
    toString() {
        return this.source.contractTemplate(this);
    }
    get name() {
        return this.astNode.name;
    }
    get fullName() {
        return this.name;
    }
    get anchor() {
        return this.name;
    }
    get linkable() {
        return [
            this,
            ...this.ownModifiers,
            ...this.ownVariables,
            ...this.ownFunctions,
            ...this.ownEvents,
            ...this.ownStructs,
            ...this.ownEnums,
        ];
    }
    get inheritance() {
        return this.astNode.linearizedBaseContracts.map(id => this.source.contractById(id));
    }
    get variables() {
        return (0, lodash_1.flatten)(this.inheritance.map(c => c.ownVariables));
    }
    get ownVariables() {
        return this.astNode.nodes
            .filter(isVariableDeclaration)
            .filter(n => n.visibility !== 'private')
            .map(n => new SourceStateVariable(this, n));
    }
    get functions() {
        return (0, lodash_1.uniqBy)((0, lodash_1.flatten)(this.inheritance.map(c => c.ownFunctions)), f => f.name === 'constructor' ? 'constructor' : f.signature);
    }
    get ownFunctions() {
        return this.astNode.nodes
            .filter(isFunctionDefinition)
            .filter(n => n.visibility !== 'private')
            .map(n => new SourceFunction(this, n))
            .filter(f => !f.isTrivialConstructor);
    }
    get privateFunctions() {
        return this.astNode.nodes
            .filter(isFunctionDefinition)
            .filter(n => n.visibility === 'private')
            .map(n => new SourceFunction(this, n));
    }
    get inheritedItems() {
        const variables = (0, lodash_1.groupBy)(this.variables, f => f.contract.astId);
        const functions = (0, lodash_1.groupBy)(this.functions, f => f.contract.astId);
        const events = (0, lodash_1.groupBy)(this.events, f => f.contract.astId);
        const modifiers = (0, lodash_1.groupBy)(this.modifiers, f => f.contract.astId);
        const structs = (0, lodash_1.groupBy)(this.structs, f => f.contract.astId);
        const enums = (0, lodash_1.groupBy)(this.enums, f => f.contract.astId);
        return this.inheritance.map(contract => ({
            contract,
            variables: variables[contract.astId],
            functions: functions[contract.astId],
            events: events[contract.astId],
            modifiers: modifiers[contract.astId],
            structs: structs[contract.astId],
            enums: enums[contract.astId],
        }));
    }
    get events() {
        return (0, lodash_1.uniqBy)((0, lodash_1.flatten)(this.inheritance.map(c => c.ownEvents)), f => f.signature);
    }
    get ownEvents() {
        return this.astNode.nodes
            .filter(isEventDefinition)
            .map(n => new SourceEvent(this, n));
    }
    get modifiers() {
        return (0, lodash_1.uniqBy)((0, lodash_1.flatten)(this.inheritance.map(c => c.ownModifiers)), f => f.signature);
    }
    get ownModifiers() {
        return this.astNode.nodes
            .filter(isModifierDefinition)
            .map(n => new SourceModifier(this, n));
    }
    get structs() {
        return (0, lodash_1.flatten)(this.inheritance.map(c => c.ownStructs));
    }
    get ownStructs() {
        return this.astNode.nodes
            .filter(isStructDefinition)
            .map(n => new SourceStruct(this, n));
    }
    get enums() {
        return (0, lodash_1.flatten)(this.inheritance.map(c => c.ownEnums));
    }
    get ownEnums() {
        return this.astNode.nodes
            .filter(isEnumDefinition)
            .map(n => new SourceEnum(this, n));
    }
    get natspec() {
        if (this.astNode.documentation === null || this.astNode.documentation === undefined) {
            return {};
        }
        return parseNatSpec(this.astNode.documentation, this);
    }
    get astId() {
        return this.astNode.id;
    }
}
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownVariables", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownFunctions", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "privateFunctions", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownEvents", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownModifiers", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownStructs", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "ownEnums", null);
__decorate([
    memoize_1.memoize
], SourceContract.prototype, "natspec", null);
exports.SourceContract = SourceContract;
class SourceContractItem {
    constructor(contract) {
        this.contract = contract;
    }
    get name() {
        return this.astNode.name;
    }
    get fullName() {
        return `${this.contract.name}.${this.name}`;
    }
    get anchor() {
        return `${this.contract.name}-${this.name}`;
    }
}
class SourceFunctionLike extends SourceContractItem {
    constructor(contract) {
        super(contract);
        this.contract = contract;
    }
    get anchor() {
        return `${this.contract.name}-${(0, handlebars_1.slug)(this.signature)}`;
    }
    get args() {
        return SourceTypedVariableArray.fromParameterList(this.astNode.parameters);
    }
    get signature() {
        return `${this.name}(${this.args.map(a => a.type).join(',')})`;
    }
    get natspec() {
        if (this.astNode.documentation === null || this.astNode.documentation === undefined) {
            return {};
        }
        return parseNatSpec(this.astNode.documentation, this);
    }
}
__decorate([
    memoize_1.memoize
], SourceFunctionLike.prototype, "args", null);
__decorate([
    memoize_1.memoize
], SourceFunctionLike.prototype, "natspec", null);
class SourceStateVariable {
    constructor(contract, astNode) {
        this.contract = contract;
        this.astNode = astNode;
    }
    get name() {
        return this.astNode.name;
    }
    get fullName() {
        return `${this.contract.name}.${this.name}`;
    }
    get anchor() {
        return `${this.contract.name}-${this.name}-${(0, handlebars_1.slug)(this.type)}`;
    }
    get type() {
        return this.astNode.typeName.typeDescriptions.typeString;
    }
    get signature() {
        return `${this.type} ${this.name}`;
    }
    get natspec() {
        warnStateVariableNatspec();
        return {};
    }
}
class SourceStructVariable {
    constructor(struct, astNode) {
        this.struct = struct;
        this.astNode = astNode;
    }
    get name() {
        return this.astNode.name;
    }
    get type() {
        return this.astNode.typeName.typeDescriptions.typeString;
    }
}
class SourceFunction extends SourceFunctionLike {
    constructor(contract, astNode) {
        super(contract);
        this.astNode = astNode;
    }
    get name() {
        const { name, kind } = this.astNode;
        const isRegularFunction = kind === 'function';
        return isRegularFunction ? name : kind;
    }
    get outputs() {
        return SourceTypedVariableArray.fromParameterList(this.astNode.returnParameters);
    }
    get visibility() {
        return this.astNode.visibility;
    }
    get isTrivialConstructor() {
        return (this.astNode.kind === "constructor" &&
            this.visibility === "public" &&
            this.args.length === 0 &&
            Object.keys(this.natspec).length === 0);
    }
}
__decorate([
    memoize_1.memoize
], SourceFunction.prototype, "outputs", null);
class SourceEvent extends SourceFunctionLike {
    constructor(contract, astNode) {
        super(contract);
        this.astNode = astNode;
    }
}
class SourceModifier extends SourceFunctionLike {
    constructor(contract, astNode) {
        super(contract);
        this.astNode = astNode;
    }
}
class SourceStruct extends SourceContractItem {
    constructor(contract, astNode) {
        super(contract);
        this.astNode = astNode;
    }
    get members() {
        return this.astNode.members.map(m => new SourceStructVariable(this, m));
    }
    get natspec() {
        warnStateVariableNatspec();
        return {};
    }
}
__decorate([
    memoize_1.memoize
], SourceStruct.prototype, "members", null);
class SourceEnum extends SourceContractItem {
    constructor(contract, astNode) {
        super(contract);
        this.astNode = astNode;
    }
    get members() {
        return this.astNode.members.map(m => m.name);
    }
    get natspec() {
        warnStateVariableNatspec();
        return {};
    }
}
__decorate([
    memoize_1.memoize
], SourceEnum.prototype, "members", null);
class SourceTypedVariable {
    constructor(typeNode, name) {
        this.typeNode = typeNode;
        this.name = name;
    }
    get type() {
        return this.typeNode.typeDescriptions.typeString;
    }
    // TODO: deprecate
    get typeName() {
        return this.type;
    }
    toString() {
        if (this.name) {
            return [this.type, this.name].join(' ');
        }
        else {
            return this.type;
        }
    }
}
class PrettyArray extends Array {
    toString() {
        return this.map(e => e.toString()).join(', ');
    }
}
class SourceTypedVariableArray extends PrettyArray {
    static fromParameterList(parameters) {
        return SourceTypedVariableArray.from(parameters.parameters.map(p => new SourceTypedVariable(p.typeName, p.name || undefined)));
    }
    get types() {
        return this.map(v => v.type);
    }
    get names() {
        return this.map(v => (v.name === undefined) ? '_' : v.name);
    }
}
function parseNatSpec(doc, context) {
    var _a, _b, _c, _d, _e, _f;
    var _g;
    const res = {};
    const tagMatches = execall(/^(?:@(\w+|custom:[a-z][a-z-]*) )?((?:(?!^@(?:\w+|custom:[a-z][a-z-]*) )[^])*)/m, doc);
    let inheritFrom;
    for (const [, tag, content] of tagMatches) {
        if (tag === 'dev') {
            (_a = res.devdoc) !== null && _a !== void 0 ? _a : (res.devdoc = '');
            res.devdoc += content;
        }
        if (tag === 'notice' || tag === undefined) {
            (_b = res.userdoc) !== null && _b !== void 0 ? _b : (res.userdoc = '');
            res.userdoc += content;
        }
        if (tag === 'title') {
            res.title = content;
        }
        if (tag === 'param') {
            const paramMatches = content.match(/(\w+) ([^]*)/);
            if (paramMatches) {
                const [, param, description] = paramMatches;
                (_c = res.params) !== null && _c !== void 0 ? _c : (res.params = []);
                res.params.push({ param, description });
            }
        }
        if (tag === 'return') {
            const paramMatches = content.match(/(\w+) ([^]*)/);
            if (paramMatches) {
                const [, param, description] = paramMatches;
                (_d = res.returns) !== null && _d !== void 0 ? _d : (res.returns = []);
                res.returns.push({ param, description });
            }
        }
        if (tag === 'inheritdoc') {
            if (!(context instanceof SourceFunction)) {
                throw new Error('@inheritdoc only supported in functions');
            }
            const parentContract = context.contract.file.contractsInScope[content.trim()];
            inheritFrom = parentContract.functions.find(f => f.name === context.name);
        }
        if (tag === null || tag === void 0 ? void 0 : tag.startsWith('custom:')) {
            const key = tag.replace(/^custom:/, '');
            (_e = res.custom) !== null && _e !== void 0 ? _e : (res.custom = {});
            (_f = (_g = res.custom)[key]) !== null && _f !== void 0 ? _f : (_g[key] = '');
            res.custom[key] += content;
        }
    }
    if (inheritFrom) {
        (0, lodash_1.defaults)(res, inheritFrom.natspec);
    }
    return res;
}
function* execall(re, text) {
    re = new RegExp(re, re.flags + (re.sticky ? '' : 'y'));
    while (true) {
        const match = re.exec(text);
        // we break out of the loop if the empty string is matched because no
        // progress will be made and it will loop infinitely
        if (match && match[0] !== '') {
            yield match;
        }
        else {
            break;
        }
    }
}
function isVariableDeclaration(node) {
    return node.nodeType === 'VariableDeclaration';
}
function isFunctionDefinition(node) {
    return node.nodeType === 'FunctionDefinition';
}
function isEventDefinition(node) {
    return node.nodeType === 'EventDefinition';
}
function isModifierDefinition(node) {
    return node.nodeType === 'ModifierDefinition';
}
function isStructDefinition(node) {
    return node.nodeType == 'StructDefinition';
}
function isEnumDefinition(node) {
    return node.nodeType == 'EnumDefinition';
}
function isContractDefinition(node) {
    return node.nodeType === 'ContractDefinition';
}
function isImportDirective(node) {
    return node.nodeType === 'ImportDirective';
}
function oneTimeLogger(msg) {
    let warned = false;
    return function () {
        if (!warned) {
            console.warn(msg);
            warned = true;
        }
    };
}
const warnStateVariableNatspec = oneTimeLogger('Warning: NatSpec is currently not available for state variables, structs, or enums.');
//# sourceMappingURL=source.js.map